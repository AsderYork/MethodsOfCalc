========================================================================
    КОНСОЛЬНОЕ ПРИЛОЖЕНИЕ. Обзор проекта WorkSpace
========================================================================
Да-да. Это снова просто набор размышлений.
И так. Производная. Сложная вещь, на самом деле. Будем разбираться

У нас есть набор простых проавил

d(A+B) = d(A)+d(B); Чудесно. Очень легко. Получается для производной суммы, нужно проссумировать производные операндов
d(const) = 0;//Неплохо.
d(A*B) = d(A)*B+A*d(B);Чуть сложнее.

d(A-B) = d(A+(-1*B)) = d(A) + d(-1*B) = d(A) + d(-1)B + -1*d(B) = d(A)-d(B); Не смотря на большую запутанность, все еще просто
d(A/B) = (d(A)*B-A*d(B))/(B*B) Достаточно хитро. Но все же жить можно

d(A(B)) = d(A)(B)*d(B); Производная композиции есть производная внешней функции(с внутренней функцией как параметром) умноженное на призводную внутренней функции. Даже описать-то трудно

А теперь самое мерзкое. В мире есть много разных функций. Скажем синусы и косинусы, у которых тоже есть производные.
Так вот их производные просто так не высчитать. По-сути для базовых функций нужно сразу же задавать и их производные
А тут хитрость в том, что функции могут превращаться друг в друга циклически, в то время как задаем мы их линейно.

И  так, вот решение:
Теперь функции в явном виде сохраняют все свои подфункции, которые теперь зовутся родителями
Каждая функция может иметь ноль(Константа), один(Результат композиции) или два(результат бинарной операции) родителя

А значит теперь лямбды проводят захват по ссылке этих явных полей.

А так же теперь функция хранит функцию своей производной.
Эти функции задаются автоматически для функции-результатов арифметических операций, композиции, и для констант
В то же время базовые функции должны в явном виде перед использованием указывать правило отыскания производной